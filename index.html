<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Moon Auto Detailing â€” Booking</title>
  <style>
    body {font-family: "Poppins", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; margin: 0; background-color: #000000;}
    label { display:block; font-weight:600; margin: 10px 0 6px; }
    input, select, button, textarea { width: 100%; padding: 10px; font-size: 16px; }
    textarea { min-height: 70px; }
    button { cursor: pointer; font-weight: 700; }
    .muted { color: #555; font-size: 14px; }
    .ok { color: #0a7a2f; font-weight: 700; }
    .bad { color: #b00020; font-weight: 700; }
    pre { background: #0b1020; color: #e7ecff; padding: 12px; border-radius: 10px; overflow:auto; }
    input[readonly] {
  background-color: #f3f4f6;
  cursor: not-allowed;
}

    /*LOCKING ADDRESS VALIDATION*/
    
    input.locked-address {
  background-color: #f3f4f6;
  cursor: not-allowed;
}

    /* =====================
   UI POLISH (SAFE) - DESKTOP DEFAULT           
   ===================== */

    .row {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 36px;
}

.row.full {
  grid-template-columns: 1fr;
}

.row > div {
  width: 100%;
}


.page-wrap {
  max-width: 860px;
  margin: 40px auto;
  padding: 0 20px;
}

h1 {
  text-align: center;
  margin-bottom: 4px;
}

.page-subtitle {
  text-align: center;
  color: #6b7280;
  margin-bottom: 24px;
}

.section-title {
  font-size: 18px;
  margin-top: 18px;
  margin-bottom: 8px;
  border-bottom: 1px solid #e5e7eb;
  padding-bottom: 4px;
}

                                /*Mobile Media Configuration*/
/* =====================
   MOBILE ONLY
   ===================== */
@media (max-width: 640px) {

 body {
  margin: 0;
}
  .page-wrap {
  max-width: 100%;
  margin: 0;
  padding: 0;
}

  /* Stack rows ONLY on mobile */
  .row {
    grid-template-columns: 1fr;
  }
  .booking-card .section-title {
  margin-top: 32px;
}

  /* Reduce card padding */
  .booking-card {
    border-radius: 0;
    padding: 20px;
  }

  /* Datetime inputs stay centered */
  input[type="datetime-local"] {
    width: 100%;
    display: block;
  }

  /* Center submit button on mobile only */
  #submitBtn {
    display: block;
    margin-left: auto;
    margin-right: auto;
  }
}

  /* Prevent overflow issues, BOX INPUT SIZES AND STYLES */
  input,
select,
textarea {
  width: 100%;
  padding: 12px;
  font-size: 16px;

  border-radius: 14px;
  border: 1px solid #cfcfcf;
  background: #ffffff;

  box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.06);
}
  /* Button sizing */
#submitBtn {
  min-width: 240px;
  padding: 14px 24px;
}


input + input,
input + select,
select + input,
select + select,
textarea {
  margin-top: 8px;
}

    /* =========================
   MOON SITE TYPOGRAPHY + ALIGNMENT
   ========================= */

/* Center all form labels and helper text */
label,
.muted,
.ok,
.bad {
  text-align: center;
}

/* Center inputs visually */
input,
select,
textarea {
  text-align: center;
}

/* Headline styling */
h1 {
  color: #7fb8e6; /* baby blue from site */
  font-weight: 700;
  letter-spacing: 0.5px;
}

/* Section headers */
h3 {
  text-align: center;
  font-weight: 600;
}
/* =========================
   BOOKING BOX STYLE
   ========================= */

.card {border-radius: 0px; padding: 26px; box-shadow: 0 18px 40px rgba(0, 0, 0, 0.12), 0 6px 18px rgba(0, 0, 0, 0.08);
      }
    /* =========================
   PRIMARY BUTTON (SITE MATCH)
   ========================= */

#submitBtn {
  background: #7fb8e6;
  color: #ffffff;
  border-radius: 999px;
  font-weight: 600;
  letter-spacing: 0.5px;
  box-shadow: 0 6px 16px rgba(127, 184, 230, 0.45);
  border: none;
  outline: none;
}

#submitBtn:hover {
  background: #6aaee2;
}

    .booking-card {
  background: #ffffff !important;
  border-radius: 22px;
  padding: 34px;
  box-shadow:
    0 18px 40px rgba(0, 0, 0, 0.12),
    0 6px 18px rgba(0, 0, 0, 0.08);
}
    /* Subtle section separation */
.booking-card .section-title {
  margin-top: 48px;
}

.booking-card .section-title + .row,
.booking-card .section-title + textarea {
  background: rgba(0, 0, 0, 0.02);
  padding: 18px;
  border-radius: 14px;
}
    /* Force rounded inputs everywhere (desktop + mobile) */
input,
select,
textarea {
  border-radius: 16px !important;
}
input[type="datetime-local"] {
  border-radius: 16px !important;
  overflow: hidden;
}
/* Hide debug log in production UI */
#log {
  display: none !important;
}
    /* =====================
   CALENDAR TOGGLE BUTTON (MOON STYLE)
   ===================== */

.calendar-toggle-btn {
  display: block;
  margin: 18px auto;
  padding: 12px 28px;
  background: #7fb8e6;
  color: #ffffff;
  border: none;
  border-radius: 999px;
  font-weight: 600;
  letter-spacing: 0.5px;
  box-shadow: 0 6px 16px rgba(127, 184, 230, 0.45);
  transition: all 0.2s ease;
}

.calendar-toggle-btn:hover {
  background: #6aaee2;
  transform: translateY(-1px);
}


    /* =====================
   WEEKLY CALENDAR (READ-ONLY)
   ===================== */

#weeklyCal {
  display: grid;
  grid-template-columns: 70px repeat(7, 1fr);
  gap: 6px;
  padding: 12px;
  border-radius: 16px;
  background: rgba(0,0,0,0.02);
}

.cal-head {
  text-align: center;
  font-weight: 700;
  font-size: 13px;
  padding: 6px;
  background: #fff;
  border: 1px solid #e5e7eb;
  border-radius: 10px;
}

.cal-time {
  text-align: right;
  font-size: 12px;
  padding: 8px;
  color: #6b7280;
}

.cal-cell {
  position: relative;
  height: 36px;
  border: 1px solid #e5e7eb;
  border-radius: 10px;
  background: #fff;
  cursor: pointer;
}
    /* Alternate day column shading using overlay */
.cal-day-even::before,
.cal-day-odd::before {
  content: "";
  position: absolute;
  inset: 0;
  border-radius: 10px;
  z-index: 0;
}

.cal-day-even::before {
  background: rgba(0, 0, 0, 0.03);
}

.cal-day-odd::before {
  background: rgba(0, 0, 0, 0.07);
}

/* Ensure cell content stays above overlay */
.cal-cell > * {
  position: relative;
  z-index: 1;
}


.cal-block {
  position: absolute;
  left: 4px;
  right: 4px;
  background: rgba(107,114,128,0.35);
  border-radius: 10px;
  pointer-events: none;
}

@media (max-width: 640px) {
  #weeklyCal {
    grid-template-columns: 58px repeat(7, 1fr);
  }
  .cal-cell {
    height: 40px;
  }
}                     
    
/* =====================
   DATETIME INPUT POLISH
   ===================== */

#start,
#end {
  background: #ffffff;
  border-radius: 18px;
  border: 1px solid #e5e7eb;
  box-shadow: inset 0 1px 2px rgba(0,0,0,0.05);
  font-weight: 500;
  padding: 12px 14px;
}

#end {
  background: #f8fbff;
  color: #7fb8e6;
  font-weight: 600;
}
/* =====================
   DESIRED START LABEL BLUE
   ===================== */

label[for="start"] {
  color: #7fb8e6;
}

    /* =====================
   HOURLY GRID CALENDAR
   ===================== */

.hourly-header,
.hourly-row {
  display: grid;
  grid-template-columns: 160px repeat(10, 1fr);
  gap: 10px;
  align-items: center;
  margin-bottom: 10px;
}

.hourly-header div {
  font-weight: 600;
  text-align: center;
  color: #7fb8e6;
}

.hourly-cell {
  height: 46px;
  border-radius: 999px;
  background: rgba(0, 0, 0, 0.04);
  transition: all 0.18s ease;
  box-shadow: 0 6px 14px rgba(0, 0, 0, 0.06);
}

.hourly-cell.booked {
  background: #e44b4b;
  color: #fff;
  font-weight: 700;
}

.hourly-cell.exposed {
  background: rgba(34, 197, 94, 0.35);
  cursor: pointer;
}

.hourly-cell.exposed:hover {
  background: rgba(34, 197, 94, 0.55);
  transform: translateY(-1px);
}

.hourly-cell.exposed.selected {
  background: #7fb8e6;
  box-shadow: 0 0 0 3px rgba(127, 184, 230, 0.6);
}

.day-label {
  background: #7fb8e6;
  color: white;
  padding: 10px 16px;
  border-radius: 999px;
  font-weight: 600;
  text-align: center;
}

.day-label.today {
  background: #facc15;
  color: #111;
}
    /* =====================
   CALENDAR TOOLBAR (MOON)
   ===================== */

.calendar-toolbar {
  display: flex;
  align-items: center;
  justify-content: center;
  gap: 14px;
  margin-bottom: 18px;
}

.cal-label {
  font-weight: 700;
  font-size: 18px;
  color: #7fb8e6;
  min-width: 180px;
  text-align: center;
}

.today-btn {
  background: #7fb8e6;
  border: none;
  color: white;
  border-radius: 999px;
  font-weight: 600;
  cursor: pointer;
  padding: 6px 14px;
  font-size: 14px;
  box-shadow: 0 4px 10px rgba(127, 184, 230, 0.35);
}

.nav-btn {
  background: none;
  border: none;
  font-size: 18px;
  font-weight: 600;
  color: #7fb8e6;
  cursor: pointer;
  padding: 4px 8px;
}

.nav-btn:hover,
.today-btn:hover {
  background: #6aaee2;
}
    #calLabel {
  font-weight: 600;
  color: #7fb8e6;
  font-size: 15px;
}


/* Pulse animation for green slots */
@keyframes pulse {
  0%   { transform: scale(1); }
  50%  { transform: scale(1.03); }
  100% { transform: scale(1); }
}

.hourly-cell.exposed {
  animation: pulse 1.6s ease-in-out infinite;
}

    /* =====================
   EXPOSED ANCHOR LAYOUT
   ===================== */

.exposed-day-row {
  padding: 18px;
  border-radius: 22px;
  background: linear-gradient(to bottom, #ffffff, #f9fbff);
  box-shadow: 0 18px 40px rgba(0,0,0,0.08);
  margin-bottom: 16px;
}

.exposed-times-wrap {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
}

.exposed-slot-btn {
  background: rgba(34,197,94,0.25);
  border: none;
  border-radius: 999px;
  padding: 8px 18px;
  font-weight: 600;
  cursor: pointer;
  transition: all 0.18s ease;
}

.exposed-slot-btn:hover {
  background: rgba(34,197,94,0.45);
  transform: translateY(-1px);
}

.exposed-slot-btn.selected {
  background: rgba(34,197,94,0.75);
  box-shadow: 0 0 0 3px rgba(127,184,230,0.6);
}

.exposed-muted {
  font-size: 14px;
  color: #6b7280;
}

  </style>                              <!--PAGE UI DESIGN END-->

  
</head>
<body>
  <div class="page-wrap">
       <div class="card booking-card">
  <h1>Moon Auto Detailing â€” Booking</h1>          <!--ACTUAL PHYSICAL TEXT STARTS-->                    
    <p class="page-subtitle">
  Mobile Auto Detailing, WE come to YOU. Book in now, no payment required today.                      <!--ALL BOOKING CONTENT-->
</p>

    <h3 class="section-title">1. Customer Information</h3> <!--Customer-Information-->
    <div class="row">
      <div>
        <label for="fullName">Full name</label>
        <input id="fullName" type="text" placeholder="First Last" autocomplete="name" required />
      </div>
      <div>
        <label for="email">Email</label>
        <input id="email" type="email" placeholder="you@email.com" autocomplete="email" required />
      </div>
    </div>
    <div class="row">
      <div>
        <label for="phone">Phone</label>
        <input id="phone" type="tel" placeholder="(518) 555-1234" autocomplete="tel" />
      </div>
      <div>
        <label for="address">Address</label>
        <input
  id="address"
  type="text"
  autocomplete="street-address"
  inputmode="text"
  placeholder="Street, City, State ZIP"
  required
/>

      </div>
    </div>

    <h3 class="section-title">2. Vehicle Details</h3> <!--Vehicle-Details-->
    <div class="row">
    <div>
        <label for="vehicleSize">Vehicle size</label> <!--Vehicle size-->
        <select id="vehicleSize" required>
          <option value="">Select sizeâ€¦</option>
          <option value="compact">compact</option>
          <option value="midsized">midsized</option>
          <option value="oversized">oversized</option>
        </select>
      </div>

      <div>
        <label for="serviceVariant">Service</label> <!--Select-service-->
        <select id="serviceVariant" required disabled>
          <option value="">Select vehicle size firstâ€¦</option>
        </select>
        <div id="serviceMeta" class="muted"></div>
      </div>
    </div>
      
    <div class="row"> 
      <div>
        <label for="year">Year</label>
        <input id="year" type="number" min="1900" max="2100" placeholder="2015" />
      </div>
      <div>
        <label for="make">Make</label>
        <input id="make" type="text" placeholder="Toyota" />
      </div>
    </div>
    <div class="row">
      <div>
        <label for="model">Model</label>
        <input id="model" type="text" placeholder="Corolla" />
      </div>
      <div>
        <label for="plate">License plate</label>
        <input id="plate" type="text" placeholder="ABC-1234" />
      </div>
    </div>

    <h3 class="section-title">3. Appointment Time</h3>
                                                                 <!-- Confirmed Bookings Calendar (read-only reference) -->
<button
  type="button"
  id="toggleCalendarBtn"
  class="calendar-toggle-btn"
>

  View availability calendar
</button>

<div id="calendarContainer" style="display:none;">
  <div id="calWrap" style="margin-top:16px;">

  <div class="calendar-toolbar">
  <button type="button" id="calPrev" class="nav-btn">â€¹</button>
  <div id="calLabel" class="cal-label"></div>
  <button type="button" id="calNext" class="nav-btn">â€º</button>
  <button type="button" id="calToday" class="today-btn">Today</button>
</div>

  <div id="hourlyCal"></div>
</div>
  
  </div> <!-- calendarContainer -->

    <div class="row">
      <div>
        <label for="start">Desired Start Time</label>
        <input id="start" type="datetime-local" required />
      </div>
      <div>
        <label for="end" style="color:#7fb8e6;">Scheduled End Time</label>
       <input id="end" type="datetime-local" readonly />
      </div>
    </div>
    <label for="serviceAddress">Address where service will be performed </label>
    <input
  id="serviceAddress"
  type="text"
  autocomplete="street-address"
  inputmode="text"
  placeholder="Start typing service addressâ€¦"
  required
/>

    <button id="submitBtn" class="primary-btn">
  Submit Booking Request
</button>
      <p class="muted" style="margin-top:14px;">
  Your request will be reviewed and confirmed shortly. Youâ€™ll receive a follow-up once itâ€™s scheduled.
</p>

    <div id="status" class="muted" style="margin-top:10px;"></div>
    <pre id="log" style="margin-top:10px; display:none;"></pre>
  </div> <!-- booking-card -->
    
  </div> <!-- page-wrap -->

  <script type="module">
                                                                                                    //DEBUG SWITCH!!                                                                           

    import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";
    const DEBUG = true;   //SWITCH HERE

    // =========================
    // CONFIG (REPLACE)
    // =========================
// =========================
// BUSINESS RULES (STEP 2)
// =========================
const BUSINESS_RULES = {
  openHour: 8,     // 8:00 AM
  closeHour: 18,  // 6:00 PM (hard stop)
  allowedWeekdays: [1, 2, 3, 4, 5] // Mondayâ€“Friday (JS: 0 = Sunday)
};
    // =========================
// SCHEDULING CONSTANTS (v1.1)
// =========================
const SLOT_MINUTES = 15;              // internal resolution
const TRAVEL_BUFFER_MINUTES = 30;     // fixed heuristic travel buffer
const MIN_BOOKABLE_GAP_MINUTES = 60; // anti-fragment rule (2 hours)

    
    const SUPABASE_URL = "https://qgmhugztrpiprnqmcyan.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFnbWh1Z3p0cnBpcHJucW1jeWFuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA1MDk1NjMsImV4cCI6MjA4NjA4NTU2M30.Mo0uRGWCjU1fOa1br2P8j1ogEZf7mDm2JseV8DFnPwI";

    if (!SUPABASE_URL.startsWith("http")) {
      throw new Error("Set SUPABASE_URL and SUPABASE_ANON_KEY in index.html");
    }

    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // Elements
    const elVehicleSize = document.getElementById("vehicleSize");
    const elServiceVariant = document.getElementById("serviceVariant");
    const elServiceMeta = document.getElementById("serviceMeta");
    const elStatus = document.getElementById("status");
    const elLog = document.getElementById("log");
    const elSubmit = document.getElementById("submitBtn");

    const elFullName = document.getElementById("fullName");
    const elEmail = document.getElementById("email");
    const elPhone = document.getElementById("phone");
    const elAddress = document.getElementById("address");

    const elYear = document.getElementById("year");
    const elMake = document.getElementById("make");
    const elModel = document.getElementById("model");
    const elPlate = document.getElementById("plate");

    const elStart = document.getElementById("start");
    const elEnd = document.getElementById("end");
    const elServiceAddress = document.getElementById("serviceAddress");

    // Hard-lock end time input (defensive)
elEnd.addEventListener("keydown", (e) => e.preventDefault());
elEnd.addEventListener("paste", (e) => e.preventDefault());

    // State
    let variantsCache = []; // {id, vehicle_size, price, duration_minutes, service:{category,level}}
    let selectedVariant = null;
    let isSubmitting = false;
    
    // Phase 5 state
let selectedStartISO = null;

                                                                            //SWITCH CHANGES THIS DEBUG
    function log(message, obj) {
  if (!DEBUG) return;

  const ts = new Date().toISOString();
  const line = obj
    ? `${ts}  ${message}\n${JSON.stringify(obj, null, 2)}\n`
    : `${ts}  ${message}\n`;

  console.log(message, obj ?? "");
  elLog.textContent = (elLog.textContent || "") + line;
}

    function selfTestTimeSlots() {
  if (!DEBUG) return;

  const today = new Date();
  today.setHours(0,0,0,0);

  const slots = generateSlotsForDay(today);
  log("Self-test: first/last slot", {
    first: slots[0] ? slots[0].toString() : null,
    last: slots[slots.length - 1] ? slots[slots.length - 1].toString() : null,
    count: slots.length
  });

  // Expect count = 40 for 8:00â€“18:00 in 15-min slots
  // (10 hours * 4 slots per hour = 40)
}


    function setStatus(type, text) {
      elStatus.className = type === "ok" ? "ok" : type === "bad" ? "bad" : "muted";
      elStatus.textContent = text;
    }

    function normalizeVehicleSize(v) {
      return (v || "").trim().toLowerCase();
    }

    function requireNonEmpty(name, value) {
      const v = (value || "").trim();
      if (!v) throw new Error(`${name} is required`);
      return v;
    }

    function parseLocalDateTimeToISO(dtLocal) {
      // dtLocal is "YYYY-MM-DDTHH:MM"
      // Interpret as local time, convert to ISO string with timezone.
      const d = new Date(dtLocal);
      if (Number.isNaN(d.getTime())) throw new Error("Invalid date/time value");
      return d.toISOString();
    }
// === ADD THESE TWO FUNCTIONS RIGHT HERE (step 1) ===
function parseDateTimeLocalToDate(dtLocal) {
  // dtLocal is "YYYY-MM-DDTHH:MM" from <input type="datetime-local">
  const [datePart, timePart] = dtLocal.split("T");
  const [y, m, d] = datePart.split("-").map(Number);
  const [hh, mm] = timePart.split(":").map(Number);
  // Create a LOCAL Date (no UTC conversion)
  return new Date(y, m - 1, d, hh, mm, 0, 0);
}

function formatDateToDateTimeLocal(d) {
  const pad = (n) => String(n).padStart(2, "0");
  const yyyy = d.getFullYear();
  const mm = pad(d.getMonth() + 1);
  const dd = pad(d.getDate());
  const hh = pad(d.getHours());
  const min = pad(d.getMinutes());
  return `${yyyy}-${mm}-${dd}T${hh}:${min}`;
}

    // =========================
// 15-MIN INTERNAL TIME HELPERS (PHASE 1)
// Pure functions only: no DOM, no Supabase, no fetch
// =========================

// Return a new Date that is rounded UP to the next 15-minute boundary
function roundUpToSlot(date, slotMinutes = SLOT_MINUTES) {
  const d = new Date(date);
  const ms = d.getTime();
  const slotMs = slotMinutes * 60_000;
  const rounded = Math.ceil(ms / slotMs) * slotMs;
  return new Date(rounded);
}

// Add minutes to a Date (returns new Date)
function addMinutes(date, minutes) {
  return new Date(date.getTime() + minutes * 60_000);
}

// Generate all slot start times (15-min) for a given day within business hours
// Returns array of Date objects: [08:00, 08:15, ... , 17:45]
function generateSlotsForDay(dayDate, openHour = BUSINESS_RULES.openHour, closeHour = BUSINESS_RULES.closeHour, slotMinutes = SLOT_MINUTES) {
  const day = new Date(dayDate);
  day.setHours(0, 0, 0, 0);

  const start = new Date(day);
  start.setHours(openHour, 0, 0, 0);

  const end = new Date(day);
  end.setHours(closeHour, 0, 0, 0);

  const slots = [];
  for (let t = new Date(start); t < end; t = addMinutes(t, slotMinutes)) {
    slots.push(new Date(t));
  }
  return slots;
}

// Utility: overlap check (half-open interval logic)
function intervalsOverlap(aStart, aEnd, bStart, bEnd) {
  return aStart < bEnd && aEnd > bStart;
}
    
// Expand a booking block to include travel buffer
function expandBookingBlock(block, bufferMinutes = TRAVEL_BUFFER_MINUTES) {
  const start = new Date(block.start);
  const end = addMinutes(new Date(block.end), bufferMinutes);
  return { start, end };
}

 // =========================
// PHASE 3 VALID START TIMES (INTERNAL)
// =========================

function isAllowedWeekday(date) {
  return BUSINESS_RULES.allowedWeekdays.includes(date.getDay());
}

function getBusinessCloseDate(dayDate) {
  const d = new Date(dayDate);
  d.setHours(BUSINESS_RULES.closeHour, 0, 0, 0);
  return d;
}

// Returns array of Date start times that are internally valid (15-min aligned)
function getValidStartTimesForDay(dayDate, serviceDurationMinutes, expandedBlocks) {
  if (!Number.isFinite(serviceDurationMinutes) || serviceDurationMinutes <= 0) return [];

  // weekday gate
  if (!isAllowedWeekday(dayDate)) return [];

  const daySlots = generateSlotsForDay(dayDate);
  const businessClose = getBusinessCloseDate(dayDate);
  const valid = [];

  for (const start of daySlots) {
    const end = addMinutes(start, serviceDurationMinutes);
const endWithTravel = addMinutes(end, TRAVEL_BUFFER_MINUTES);

// must finish service by close (travel may extend past close)
if (end > businessClose) continue;

// candidate must also reserve its travel buffer after service
const conflicts = expandedBlocks.some(b =>
  intervalsOverlap(start, endWithTravel, b.start, b.end)
);
if (conflicts) continue;

    valid.push(start);
  }

  return valid;
}

// DEV-ONLY SELF TEST
function selfTestValidStarts(dayDate, serviceDurationMinutes, expandedBlocks) {
  if (!DEBUG) return;

  const valid = getValidStartTimesForDay(
    dayDate,
    serviceDurationMinutes,
    expandedBlocks
  );

  console.log("Valid start times (preview)", {
    day: dayDate.toDateString(),
    duration_minutes: serviceDurationMinutes,
    count: valid.length,
    first10: valid.slice(0, 10).map(d =>
      d.toLocaleTimeString([], { hour: "numeric", minute: "2-digit" })
    )
  });
}

   // =========================
// PHASE 4: EXPOSED (CUSTOMER-SAFE) START TIMES
// =========================

function isOnHour(date) {
  return date.getMinutes() === 0;
}

function getExposedStartTimesForDay(dayDate, serviceDurationMinutes, expandedBlocks) {
  const valid = getValidStartTimesForDay(dayDate, serviceDurationMinutes, expandedBlocks);
  if (!valid.length) return [];

  // Split valid times into continuous gaps
  const gaps = [];
  let currentGap = [valid[0]];

  for (let i = 1; i < valid.length; i++) {
    const prev = valid[i - 1];
    const curr = valid[i];
    const diffMinutes = (curr - prev) / 60000;

    if (diffMinutes === SLOT_MINUTES) {
      currentGap.push(curr);
    } else {
      gaps.push(currentGap);
      currentGap = [curr];
    }
  }
  gaps.push(currentGap);

  const exposed = [];
  const businessClose = getBusinessCloseDate(dayDate);
  for (const gap of gaps) {


  let candidates = [];

for (const start of gap) {
  if (!passesFragmentFilter(start, serviceDurationMinutes, expandedBlocks, dayDate)) {
    continue;
  }

  const endWithTravel = addMinutes(start, serviceDurationMinutes + TRAVEL_BUFFER_MINUTES);

  let nextBoundary = businessClose;
  for (const b of expandedBlocks) {
    if (b.start > start && b.start < nextBoundary) {
      nextBoundary = b.start;
    }
  }

  const remainingAfter = (nextBoundary - endWithTravel) / 60000;
  const usableAfter = remainingAfter >= MIN_BOOKABLE_GAP_MINUTES ? remainingAfter : 0;

  candidates.push({ start, usableAfter });
}

if (!candidates.length) continue;

// Sort by usableAfter descending, tie â†’ earlier first
candidates.sort((a, b) => {
  if (b.usableAfter !== a.usableAfter) {
    return b.usableAfter - a.usableAfter;
  }
  return a.start - b.start;
});

// Always take best
exposed.push(candidates[0].start);

// If gap is large enough, take second-best if meaningful
const gapStart = gap[0];
let gapEnd = businessClose;

for (const b of expandedBlocks) {
  if (b.start > gapStart && b.start < gapEnd) {
    gapEnd = b.start;
  }
}

const gapLengthMinutes = (gapEnd - gapStart) / 60000;


if (gapLengthMinutes > 240 && candidates.length > 1) {

  const midpoint = gapStart.getTime() + (gapLengthMinutes / 2) * 60000;

  let closest = null;
  let smallestDiff = Infinity;

  for (const c of candidates) {
    const diff = Math.abs(c.start.getTime() - midpoint);
    if (diff < smallestDiff) {
      smallestDiff = diff;
      closest = c.start;
    }
  }

  if (closest && closest.getTime() !== candidates[0].start.getTime()) {
  exposed.push(closest);
}

} // closes if (gapLengthMinutes > 240 ...)

} // closes for (const gap of gaps)

return exposed;
}




function selfTestExposedStarts(dayDate, serviceDurationMinutes, expandedBlocks) {
  if (!DEBUG) return;

  const exposed = getExposedStartTimesForDay(
    dayDate,
    serviceDurationMinutes,
    expandedBlocks
  );

  console.log("Exposed start times (customer-safe)", {
    day: dayDate.toDateString(),
    duration_minutes: serviceDurationMinutes,
    count: exposed.length,
    times: exposed.map(d =>
      d.toLocaleTimeString([], { hour: "numeric", minute: "2-digit" })
    )
  });
}
    // =========================
// PHASE 4.5 â€” FRAGMENT FILTER
// =========================
function passesFragmentFilter(start, serviceDurationMinutes, expandedBlocks, dayDate) {
  // Open-day bypass â€” do not fragment-filter when no bookings exist
if (!expandedBlocks.length) {
  return true;
}
  const serviceEnd = addMinutes(start, serviceDurationMinutes + TRAVEL_BUFFER_MINUTES);
  const businessClose = getBusinessCloseDate(dayDate);

  let nextBoundary = businessClose;

  for (const b of expandedBlocks) {
    if (b.start > start && b.start < nextBoundary) {
      nextBoundary = b.start;
    }
  }

  const remainingMinutes = (nextBoundary - serviceEnd) / 60000;

  // If perfectly tight or no remaining gap, allow
  if (remainingMinutes <= 0) return true;

  // Block unusable fragments
  if (remainingMinutes < MIN_BOOKABLE_GAP_MINUTES) {
    return false;
  }

  return true;
}

// =========================
// BUSINESS HOURS VALIDATION
// =========================
function isBookingWithinBusinessRules(startLocal, endLocal) {
  // Must be same calendar day
  if (
    startLocal.getFullYear() !== endLocal.getFullYear() ||
    startLocal.getMonth() !== endLocal.getMonth() ||
    startLocal.getDate() !== endLocal.getDate()
  ) {
    return false;
  }

  // Weekday check (Monâ€“Fri only)
  const day = startLocal.getDay();
  if (!BUSINESS_RULES.allowedWeekdays.includes(day)) {
    return false;
  }

  // Time window check
  const startHour = startLocal.getHours() + startLocal.getMinutes() / 60;
  const endHour = endLocal.getHours() + endLocal.getMinutes() / 60;

  if (startHour < BUSINESS_RULES.openHour) return false;
  if (endHour > BUSINESS_RULES.closeHour) return false;

  return true;
}

   function recalcEndTimePreview() {
  if (!elStart.value) return;
  if (!selectedVariant?.duration_minutes) return;

  const startLocal = parseDateTimeLocalToDate(elStart.value);
  const durationMinutes = Number(selectedVariant.duration_minutes);

  const endLocal = new Date(startLocal.getTime() + durationMinutes * 60_000);
  elEnd.value = formatDateToDateTimeLocal(endLocal);
}


// ðŸ‘‡ ADD THIS FUNCTION DIRECTLY HERE
function computeScheduledEnd(startLocal, durationMinutes) {
  const startDate = new Date(startLocal);
  if (Number.isNaN(startDate.getTime())) {
    throw new Error("Invalid scheduled start time");
  }

  const endDate = new Date(startDate.getTime() + durationMinutes * 60 * 1000);

  const pad = n => String(n).padStart(2, "0");
  return `${endDate.getFullYear()}-${pad(endDate.getMonth() + 1)}-${pad(endDate.getDate())}T${pad(endDate.getHours())}:${pad(endDate.getMinutes())}`;
}
    function resetServiceDropdown(msg) {
      elServiceVariant.innerHTML = `<option value="">${msg}</option>`;
      elServiceVariant.disabled = true;
      elServiceMeta.textContent = "";
      selectedVariant = null;
    }

    function renderServiceDropdown(vehicleSize) {
      const filtered = variantsCache
        .filter(v => v.vehicle_size === vehicleSize)
        .map(v => {
          const cat = v.service?.category ?? "Unknown Category";
          const lvl = (v.service?.level ?? "?");
          const label = `${cat} â€” Level ${lvl} (${v.vehicle_size}) â€” ${v.duration_minutes} min â€” $${v.price}`;
          return { id: v.id, label };
        });

      if (!filtered.length) {
        resetServiceDropdown("No services available for this vehicle size");
        log("No service variants found for vehicle size", { vehicleSize, totalVariants: variantsCache.length });
        return;
      }

      elServiceVariant.disabled = false;
      elServiceVariant.innerHTML = `<option value="">Select serviceâ€¦</option>` +
        filtered.map(o => `<option value="${o.id}">${o.label}</option>`).join("");
    }

    async function loadServiceVariants() {
      setStatus("muted", "Loading servicesâ€¦");
      resetServiceDropdown("Loadingâ€¦");

                                              // Explicit embedded relation; DO NOT rely on implicit joins returning null silently
                                              //THIS IS SERVICE_VARIANTS NOT LOADING DEBUG 
      const { data, error } = await supabase
        .from("service_variants")
        .select("id, vehicle_size, price, duration_minutes, service:services(category, level)")
        .eq("active", true);

      if (error) {
        setStatus("bad", "Failed to load services. See log.");
        log("Service load error", error);
        resetServiceDropdown("Failed to load services");
        return;
      }

      if (!Array.isArray(data)) {
        setStatus("bad", "Service data shape invalid. See log.");
        log("Service data not array", data);
        resetServiceDropdown("Service data invalid");
        return;
      }

      // Validate minimum fields; log anomalies, don't crash
      variantsCache = data.map(v => ({
        id: v.id,
        vehicle_size: normalizeVehicleSize(v.vehicle_size),
        price: v.price,
        duration_minutes: v.duration_minutes,
        service: v.service || null
      }));

      setStatus("muted", "");
      log("Loaded service variants", { count: variantsCache.length });            //SERVICE VARIANTS DEBUG ENDS HERE

      // If user already selected vehicle size, render
      const vs = normalizeVehicleSize(elVehicleSize.value);
      if (vs) renderServiceDropdown(vs);
      else resetServiceDropdown("Select vehicle size firstâ€¦");
    }

    elVehicleSize.addEventListener("change", () => {
      const vs = normalizeVehicleSize(elVehicleSize.value);
      if (!vs) {
        resetServiceDropdown("Select vehicle size firstâ€¦");
        return;
      }
      if (!["compact","midsized","oversized"].includes(vs)) {
        resetServiceDropdown("Invalid vehicle size");
        log("Invalid vehicle size selected", { vs });
        return;
      }
      renderServiceDropdown(vs);
    });

    elServiceVariant.addEventListener("change", async () => {
  const id = elServiceVariant.value;
  selectedVariant = variantsCache.find(v => v.id === id) || null;
      selectedStartISO = null;
elStart.value = "";
recalcEndTimePreview();
loadCalendar();

  if (!selectedVariant) {
    elServiceMeta.textContent = "";
    await loadCalendar(); // Clear availability if no service
    return;
  }

  const cat = selectedVariant.service?.category ?? "Unknown Category";
  const lvl = selectedVariant.service?.level ?? "?";

  elServiceMeta.textContent =
    `Selected: ${cat} Level ${lvl} â€” ${selectedVariant.duration_minutes} minutes`;

  recalcEndTimePreview();

  // ðŸ”¥ FORCE CALENDAR REBUILD
  await loadCalendar();
});


    // Core booking flow (no read-after-write after inserts)
async function hasBookingConflict(requestedStartISO, requestedEndISO) {
  const { count, error } = await supabase
  .from("booking_time_windows")
  .select("scheduled_start", { count: "exact", head: true })
  .lt("scheduled_start", requestedEndISO)
  .gt("scheduled_end", requestedStartISO);

  if (error) {
    log("Conflict check failed", error);
    throw new Error("Unable to verify availability. Please try again.");
  }

  return count > 0;
}    
    async function submitBooking() {
      if (isSubmitting) return;
isSubmitting = true;

      elSubmit.disabled = true;
      setStatus("muted", "Submittingâ€¦");

      try {
        const vehicle_size = normalizeVehicleSize(requireNonEmpty("Vehicle size", elVehicleSize.value));
        if (!["compact","midsized","oversized"].includes(vehicle_size)) throw new Error("Vehicle size must be compact, midsized, or oversized (lowercase)");

        const service_variant_id = requireNonEmpty("Service", elServiceVariant.value);
        const email = requireNonEmpty("Email", elEmail.value).toLowerCase();

        const full_name = requireNonEmpty("Full name", elFullName.value);
        const address = requireNonEmpty("Customer address", elAddress.value);
        const phone = (elPhone.value || "").trim() || null;

        const service_address = requireNonEmpty("Service address", elServiceAddress.value);

        // --- Step 2: derive end time from service duration (LOCAL time) ---
const startLocal = parseDateTimeLocalToDate(
  requireNonEmpty("Scheduled start", elStart.value)
);

const durationMinutes = Number(selectedVariant?.duration_minutes);
if (!Number.isFinite(durationMinutes) || durationMinutes <= 0) {
  throw new Error("Invalid service duration. Please re-select your service.");
}
      log("Duration minutes used", {
  raw: selectedVariant?.duration_minutes,
  coerced: durationMinutes
});

// Add duration in LOCAL time
const endLocal = new Date(startLocal.getTime() + durationMinutes * 60_000);

// Autofill + lock the end-time input for UI consistency
elEnd.value = formatDateToDateTimeLocal(endLocal);

// Convert to ISO ONLY for database usage
const scheduled_start = startLocal.toISOString();
const scheduled_end = endLocal.toISOString();
// --- End Step 2 ---

        if (new Date(scheduled_end) <= new Date(scheduled_start)) throw new Error("Scheduled end must be after scheduled start");
        // --- Step 2.5: enforce business hours & weekdays ---
if (!isBookingWithinBusinessRules(startLocal, endLocal)) {
  throw new Error(
    "Bookings are available Mondayâ€“Friday only, between 8:00 AM and 6:00 PM. " +
    "The selected service must fully complete by 6:00 PM."
  );
}
// --- End Step 2.5 ---

        // Calendar conflict check (block overlaps)
const conflict = await hasBookingConflict(scheduled_start, scheduled_end);
if (conflict) {
  throw new Error("Selected time is unavailable. Please choose another slot.");
}
        
        // Step 1: find existing customer by email (SELECT allowed only by email header policy)
        const customerLookupClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
          auth: { persistSession: false },
          global: { headers: { "x-customer-email": email } }
        });

        const { data: existingCustomers, error: selErr } = await customerLookupClient
          .from("customers")
          .select("id,email")
          .eq("email", email)
          .limit(1);

        if (selErr) {
          // If RLS blocks this, you WILL see it here
          log("Customer select error (RLS?)", selErr);
          throw new Error("Customer lookup failed (likely RLS). See log.");
        }

        let customer_id;
        if (existingCustomers && existingCustomers.length === 1) {
          customer_id = existingCustomers[0].id;
          log("Found existing customer", { customer_id, email });
        } else {
          // New customer: generate UUID client-side, insert WITHOUT .select()
          customer_id = crypto.randomUUID();
          const { error: insCustErr } = await supabase
            .from("customers")
            .insert([{ id: customer_id, full_name, email, phone, address }]);

          if (insCustErr) {
            log("Customer insert error", insCustErr);
            throw new Error("Customer creation failed. See log.");
          }
          log("Created new customer (no select after insert)", { customer_id, email });
        }

        // Step 2: create vehicle record (new every booking), client-generated UUID, insert WITHOUT .select()
        const vehicle_id = crypto.randomUUID();
        const vehicle_year = elYear.value ? Number(elYear.value) : null;
        const vehicle_make = (elMake.value || "").trim() || null;
        const vehicle_model = (elModel.value || "").trim() || null;
        const license_plate = (elPlate.value || "").trim() || null;

        const { error: insVehErr } = await supabase
          .from("vehicles")
          .insert([{
            id: vehicle_id,
            customer_id,
            vehicle_size,
            vehicle_year,
            vehicle_make,
            vehicle_model,
            license_plate
          }]);

        if (insVehErr) {
          log("Vehicle insert error", insVehErr);
          throw new Error("Vehicle creation failed. See log.");
        }
        log("Created vehicle (no select after insert)", { vehicle_id });

        // Step 3: create booking (status pending), insert WITHOUT .select()
        const { error: insBookErr } = await supabase
          .from("bookings")
          .insert([{
            customer_id,
            vehicle_id,
            service_variant_id,
            service_address,
            scheduled_start,
            scheduled_end,
            status: "pending"
          }]);

       if (insBookErr) {
  log("Booking insert error", insBookErr);

  // Handle overlap constraint cleanly
  if (insBookErr.code === "23P01" || insBookErr.message?.includes("bookings_no_overlap")) {
    throw new Error("Selected time is unavailable. Please choose another slot.");
  }

  throw new Error("Booking creation failed. Please try again.");
}


        setStatus("ok", "Your booking has been received and will be confirmed shortly.");
        log("Booking created", { customer_id, vehicle_id, service_variant_id });

      } catch (e) {
        setStatus("bad", e?.message || "Unknown error");
        log("Submit failure", { message: e?.message, stack: e?.stack });
      } finally {
        isSubmitting = false;
        elSubmit.disabled = false;
      }
    }

    elStart.addEventListener("change", recalcEndTimePreview);
    elSubmit.addEventListener("click", submitBooking);

    // =========================
// GOOGLE PLACES AUTOCOMPLETE
// =========================
function initAddressAutocomplete() {
  if (!window.google || !google.maps?.places) return;

  const options = {
    types: ["address"],
    componentRestrictions: { country: "us" },
    fields: ["address_components"]
  };

  function attachAutocomplete(inputEl) {
    const autocomplete = new google.maps.places.Autocomplete(inputEl, options);

    autocomplete.addListener("place_changed", () => {
  const place = autocomplete.getPlace();
  if (!place || !place.address_components) return;

  const components = {};
  for (const c of place.address_components) {
    for (const t of c.types) {
      components[t] = c.long_name;
    }
  }

  const street =
    [components.street_number, components.route]
      .filter(Boolean)
      .join(" ");

  const city =
    components.locality ||
    components.sublocality ||
    components.postal_town ||
    "";

  const state = components.administrative_area_level_1 || "";
  const zip = components.postal_code || "";

  const fullAddress = [street, city, state, zip]
    .filter(Boolean)
    .join(", ");

  inputEl.value = fullAddress;
      inputEl.readOnly = true;
inputEl.classList.add("locked-address");

});
  }

  const customerAddress = document.getElementById("address");
  const serviceAddress = document.getElementById("serviceAddress");

  if (customerAddress) attachAutocomplete(customerAddress);
  if (serviceAddress) attachAutocomplete(serviceAddress);
}
// =========================
// HOURLY CALENDAR (STATE + HELPERS)
// =========================
let calWeekStart = new Date();
calWeekStart.setHours(0, 0, 0, 0);
calWeekStart.setDate(calWeekStart.getDate() - calWeekStart.getDay()); // Sunday

function addDays(d, n) {
  const x = new Date(d);
  x.setDate(x.getDate() + n);
  return x;
}
    function formatHourLabel(hour) {
  const h = hour % 12 || 12;
  const ampm = hour < 12 ? "AM" : "PM";
  return `${h}:00 ${ampm}`;
}


// =========================
// HOURLY CALENDAR (RENDER)
// =========================
async function loadCalendar() {

  const hourlyCal = document.getElementById("hourlyCal");
  const calLabel = document.getElementById("calLabel");
  if (!hourlyCal) return;

  hourlyCal.innerHTML = "";

  const weekEnd = addDays(calWeekStart, 7);

  const start = calWeekStart;
const end = addDays(weekEnd, -1);

const options = { month: "long" };
const monthName = start.toLocaleDateString(undefined, options);

calLabel.textContent = `${monthName} ${start.getDate()}â€“${end.getDate()}`;


  // =========================
  // HEADER (HOURS)
  // =========================
  const header = document.createElement("div");
  header.className = "hourly-header";

  header.innerHTML = `<div></div>`; // empty corner cell

  for (let h = 8; h <= 17; h++) {
    const hourCell = document.createElement("div");
    hourCell.textContent = formatHourLabel(h);
    header.appendChild(hourCell);
  }

  hourlyCal.appendChild(header);

  // =========================
  // FETCH BOOKING BLOCKS
  // =========================
  let blocks = [];

try {
  const resp = await fetch(
    `/api/list-calendar-blocks?timeMin=${calWeekStart.toISOString()}&timeMax=${weekEnd.toISOString()}`
  );

  if (resp.ok) {
    const data = await resp.json();
    blocks = data.blocks || [];
  }
} catch (e) {
  console.error("Calendar fetch failed:", e);
}

// ðŸ‘‡ MUST be outside try block
const expandedBlocks = blocks.map(b => expandBookingBlock(b));


  // =========================
  // BUILD EXPOSED START MAP
  // =========================
  const exposedByDay = {};

  for (let d = 0; d < 7; d++) {

    const day = addDays(calWeekStart, d);

    const exposed = selectedVariant
      ? getExposedStartTimesForDay(
          day,
          Number(selectedVariant.duration_minutes),
          expandedBlocks
        )
      : [];

    exposedByDay[day.toDateString()] =
      exposed.map(x => x.getTime());
  }

  // =========================
  // RENDER GRID ROWS
  // =========================
  for (let d = 0; d < 7; d++) {

    const day = addDays(calWeekStart, d);
    const dayKey = day.toDateString();
    const exposedSet = new Set(exposedByDay[dayKey] || []);

    const isToday =
      day.toDateString() === new Date().toDateString();

    const row = document.createElement("div");
    row.className = "hourly-row";

    row.innerHTML = `
      <div class="day-label ${isToday ? "today" : ""}">
        ${day.toLocaleDateString(undefined, {
          weekday: "long",
          month: "numeric",
          day: "numeric"
        })}
      </div>
    `;

    for (let h = 8; h <= 17; h++) {

      const cellStart = new Date(day);
      cellStart.setHours(h, 0, 0, 0);

      const cellEnd = new Date(cellStart);
      cellEnd.setHours(cellEnd.getHours() + 1);

      const cell = document.createElement("div");
      cell.className = "hourly-cell";

      const isBooked = expandedBlocks.some(b =>
  cellStart < b.end && cellEnd > b.start
);

if (isBooked) {

  cell.classList.add("booked");

} else if (exposedSet.has(cellStart.getTime())) {

  cell.classList.add("exposed");

  cell.addEventListener("click", () => {

    document
      .querySelectorAll(".hourly-cell.exposed.selected")
      .forEach(el => el.classList.remove("selected"));

    cell.classList.add("selected");

    elStart.value = formatDateToDateTimeLocal(cellStart);
    selectedStartISO = cellStart.toISOString();
    recalcEndTimePreview();
  });
}

row.appendChild(cell);
    }

    hourlyCal.appendChild(row);
  }
}   // â† THIS closes loadCalendar()

// =========================
// CALENDAR NAVIGATION
// =========================
document.getElementById("calPrev").onclick = () => {
  calWeekStart = addDays(calWeekStart, -7);
  loadCalendar();
};

document.getElementById("calNext").onclick = () => {
  calWeekStart = addDays(calWeekStart, 7);
  loadCalendar();
};

document.getElementById("calToday").onclick = () => {
  calWeekStart = new Date();
  calWeekStart.setHours(0,0,0,0);
  calWeekStart.setDate(calWeekStart.getDate() - calWeekStart.getDay());
  loadCalendar();
};
    //Epand blocks helper function
  function selfTestExpandedBlocks(blocks) {
  if (!DEBUG) return;

  blocks.forEach((b, i) => {
    log(`Expanded block ${i}`, {
      start: b.start.toString(),
      end: b.end.toString()
    });
  });
}

// =========================
// CALENDAR TOGGLE (UI ONLY)
// =========================
const toggleBtn = document.getElementById("toggleCalendarBtn");
const calContainer = document.getElementById("calendarContainer");

if (toggleBtn && calContainer) {
  toggleBtn.addEventListener("click", () => {
    const isOpen = calContainer.style.display === "block";
    calContainer.style.display = isOpen ? "none" : "block";
    toggleBtn.textContent = isOpen
      ? "View availability calendar"
      : "Hide availability calendar";
  });
}

    // Initial load
loadCalendar();
    loadServiceVariants();
    selfTestTimeSlots();
function waitForGooglePlaces() {
  if (window.google && google.maps?.places) {
    initAddressAutocomplete();
  } else {
    setTimeout(waitForGooglePlaces, 100);
  }
}
waitForGooglePlaces();                                                                  //PLACES API LINK//
  </script>
    <script
  src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAszMW1x5-TUHnlDkxpms-z4rDfHxDcTyI&libraries=places&loading=async"
  async
  defer
></script>


</body>
</html>
