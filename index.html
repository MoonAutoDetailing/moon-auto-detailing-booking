<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Moon Auto Detailing â€” Booking</title>
  <style>
    body { font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; margin: 20px; max-width: 860px; }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: 12px; }
    label { display:block; font-weight:600; margin: 10px 0 6px; }
    input, select, button, textarea { width: 100%; padding: 10px; font-size: 16px; }
    textarea { min-height: 70px; }
    button { cursor: pointer; font-weight: 700; }
    .card { border: 1px solid #ddd; border-radius: 10px; padding: 14px; margin-top: 14px; }
    .muted { color: #555; font-size: 14px; }
    .ok { color: #0a7a2f; font-weight: 700; }
    .bad { color: #b00020; font-weight: 700; }
    pre { background: #0b1020; color: #e7ecff; padding: 12px; border-radius: 10px; overflow:auto; }
    input[readonly] {
  background-color: #f3f4f6;
  cursor: not-allowed;
}
  </style>
</head>
<body>
  <h1>Moon Auto Detailing â€” Booking</h1>
  <p class="muted">Client-side only. Inserts only. No read-after-write after inserts.</p>

  <div class="card">
    <div class="row">
      <div>
        <label for="vehicleSize">Vehicle size (required)</label>
        <select id="vehicleSize" required>
          <option value="">Select sizeâ€¦</option>
          <option value="compact">compact</option>
          <option value="midsized">midsized</option>
          <option value="oversized">oversized</option>
        </select>
      </div>

      <div>
        <label for="serviceVariant">Service (required)</label>
        <select id="serviceVariant" required disabled>
          <option value="">Select vehicle size firstâ€¦</option>
        </select>
        <div id="serviceMeta" class="muted"></div>
      </div>
    </div>

    <h3>Customer</h3>
    <div class="row">
      <div>
        <label for="fullName">Full name (required)</label>
        <input id="fullName" type="text" placeholder="Darren Moon" required />
      </div>
      <div>
        <label for="email">Email (required)</label>
        <input id="email" type="email" placeholder="you@email.com" required />
      </div>
    </div>
    <div class="row">
      <div>
        <label for="phone">Phone</label>
        <input id="phone" type="tel" placeholder="(518) 555-1234" />
      </div>
      <div>
        <label for="address">Address (required)</label>
        <input id="address" type="text" placeholder="Street, City, State ZIP" required />
      </div>
    </div>

    <h3>Vehicle (a new record is created every booking)</h3>
    <div class="row">
      <div>
        <label for="year">Year</label>
        <input id="year" type="number" min="1900" max="2100" placeholder="2015" />
      </div>
      <div>
        <label for="make">Make</label>
        <input id="make" type="text" placeholder="GMC" />
      </div>
    </div>
    <div class="row">
      <div>
        <label for="model">Model</label>
        <input id="model" type="text" placeholder="Sierra 1500" />
      </div>
      <div>
        <label for="plate">License plate</label>
        <input id="plate" type="text" placeholder="ABC-1234" />
      </div>
    </div>

    <h3>Booking</h3>
    <div class="row">
      <div>
        <label for="start">Scheduled start (required)</label>
        <input id="start" type="datetime-local" required />
      </div>
      <div>
        <label for="end">Scheduled end (required)</label>
       <input id="end" type="datetime-local" readonly />
      </div>
    </div>
    <label for="serviceAddress">Service address (required)</label>
    <textarea id="serviceAddress" placeholder="If same as customer address, paste it here." required></textarea>

    <button id="submitBtn">Create booking</button>

    <div id="status" class="muted" style="margin-top:10px;"></div>
    <pre id="log" style="margin-top:10px; display:none;"></pre>
  </div>

  <script type="module">
    import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";

    // =========================
    // CONFIG (REPLACE)
    // =========================
// =========================
// BUSINESS RULES (STEP 2)
// =========================
const BUSINESS_RULES = {
  openHour: 8,     // 8:00 AM
  closeHour: 18,  // 6:00 PM (hard stop)
  allowedWeekdays: [1, 2, 3, 4, 5] // Mondayâ€“Friday (JS: 0 = Sunday)
};
    
    const SUPABASE_URL = "https://qgmhugztrpiprnqmcyan.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFnbWh1Z3p0cnBpcHJucW1jeWFuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA1MDk1NjMsImV4cCI6MjA4NjA4NTU2M30.Mo0uRGWCjU1fOa1br2P8j1ogEZf7mDm2JseV8DFnPwI";

    if (!SUPABASE_URL.startsWith("http")) {
      throw new Error("Set SUPABASE_URL and SUPABASE_ANON_KEY in index.html");
    }

    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // Elements
    const elVehicleSize = document.getElementById("vehicleSize");
    const elServiceVariant = document.getElementById("serviceVariant");
    const elServiceMeta = document.getElementById("serviceMeta");
    const elStatus = document.getElementById("status");
    const elLog = document.getElementById("log");
    const elSubmit = document.getElementById("submitBtn");

    const elFullName = document.getElementById("fullName");
    const elEmail = document.getElementById("email");
    const elPhone = document.getElementById("phone");
    const elAddress = document.getElementById("address");

    const elYear = document.getElementById("year");
    const elMake = document.getElementById("make");
    const elModel = document.getElementById("model");
    const elPlate = document.getElementById("plate");

    const elStart = document.getElementById("start");
    const elEnd = document.getElementById("end");
    const elServiceAddress = document.getElementById("serviceAddress");

    // Hard-lock end time input (defensive)
elEnd.addEventListener("keydown", (e) => e.preventDefault());
elEnd.addEventListener("paste", (e) => e.preventDefault());

    // State
    let variantsCache = []; // {id, vehicle_size, price, duration_minutes, service:{category,level}}
    let selectedVariant = null;
    let isSubmitting = false;


    function log(message, obj) {
      const ts = new Date().toISOString();
      const line = obj ? `${ts}  ${message}\n${JSON.stringify(obj, null, 2)}\n` : `${ts}  ${message}\n`;
      console.log(message, obj ?? "");
      elLog.style.display = "block";
      elLog.textContent = (elLog.textContent || "") + line;
    }

    function setStatus(type, text) {
      elStatus.className = type === "ok" ? "ok" : type === "bad" ? "bad" : "muted";
      elStatus.textContent = text;
    }

    function normalizeVehicleSize(v) {
      return (v || "").trim().toLowerCase();
    }

    function requireNonEmpty(name, value) {
      const v = (value || "").trim();
      if (!v) throw new Error(`${name} is required`);
      return v;
    }

    function parseLocalDateTimeToISO(dtLocal) {
      // dtLocal is "YYYY-MM-DDTHH:MM"
      // Interpret as local time, convert to ISO string with timezone.
      const d = new Date(dtLocal);
      if (Number.isNaN(d.getTime())) throw new Error("Invalid date/time value");
      return d.toISOString();
    }
// === ADD THESE TWO FUNCTIONS RIGHT HERE (step 1) ===
function parseDateTimeLocalToDate(dtLocal) {
  // dtLocal is "YYYY-MM-DDTHH:MM" from <input type="datetime-local">
  const [datePart, timePart] = dtLocal.split("T");
  const [y, m, d] = datePart.split("-").map(Number);
  const [hh, mm] = timePart.split(":").map(Number);
  // Create a LOCAL Date (no UTC conversion)
  return new Date(y, m - 1, d, hh, mm, 0, 0);
}

function formatDateToDateTimeLocal(d) {
  const pad = (n) => String(n).padStart(2, "0");
  const yyyy = d.getFullYear();
  const mm = pad(d.getMonth() + 1);
  const dd = pad(d.getDate());
  const hh = pad(d.getHours());
  const min = pad(d.getMinutes());
  return `${yyyy}-${mm}-${dd}T${hh}:${min}`;
}
// =========================
// BUSINESS HOURS VALIDATION
// =========================

  const pad = (n) => String(n).padStart(2, "0");
  const yyyy = d.getFullYear();
  const mm = pad(d.getMonth() + 1);
  const dd = pad(d.getDate());
  const hh = pad(d.getHours());
  const min = pad(d.getMinutes());
  return `${yyyy}-${mm}-${dd}T${hh}:${min}`;
}
// === END ADD ===
   function recalcEndTimePreview() {
  if (!elStart.value) return;
  if (!selectedVariant?.duration_minutes) return;

  const startLocal = parseDateTimeLocalToDate(elStart.value);
  const durationMinutes = Number(selectedVariant.duration_minutes);

  const endLocal = new Date(startLocal.getTime() + durationMinutes * 60_000);
  elEnd.value = formatDateToDateTimeLocal(endLocal);
}


// ðŸ‘‡ ADD THIS FUNCTION DIRECTLY HERE
function computeScheduledEnd(startLocal, durationMinutes) {
  const startDate = new Date(startLocal);
  if (Number.isNaN(startDate.getTime())) {
    throw new Error("Invalid scheduled start time");
  }

  const endDate = new Date(startDate.getTime() + durationMinutes * 60 * 1000);

  const pad = n => String(n).padStart(2, "0");
  return `${endDate.getFullYear()}-${pad(endDate.getMonth() + 1)}-${pad(endDate.getDate())}T${pad(endDate.getHours())}:${pad(endDate.getMinutes())}`;
}
    function resetServiceDropdown(msg) {
      elServiceVariant.innerHTML = `<option value="">${msg}</option>`;
      elServiceVariant.disabled = true;
      elServiceMeta.textContent = "";
      selectedVariant = null;
    }

    function renderServiceDropdown(vehicleSize) {
      const filtered = variantsCache
        .filter(v => v.vehicle_size === vehicleSize)
        .map(v => {
          const cat = v.service?.category ?? "Unknown Category";
          const lvl = (v.service?.level ?? "?");
          const label = `${cat} â€” Level ${lvl} (${v.vehicle_size}) â€” ${v.duration_minutes} min â€” $${v.price}`;
          return { id: v.id, label };
        });

      if (!filtered.length) {
        resetServiceDropdown("No services available for this vehicle size");
        log("No service variants found for vehicle size", { vehicleSize, totalVariants: variantsCache.length });
        return;
      }

      elServiceVariant.disabled = false;
      elServiceVariant.innerHTML = `<option value="">Select serviceâ€¦</option>` +
        filtered.map(o => `<option value="${o.id}">${o.label}</option>`).join("");
    }

    async function loadServiceVariants() {
      setStatus("muted", "Loading servicesâ€¦");
      resetServiceDropdown("Loadingâ€¦");

      // Explicit embedded relation; DO NOT rely on implicit joins returning null silently
      const { data, error } = await supabase
        .from("service_variants")
        .select("id, vehicle_size, price, duration_minutes, service:services(category, level)")
        .eq("active", true);

      if (error) {
        setStatus("bad", "Failed to load services. See log.");
        log("Service load error", error);
        resetServiceDropdown("Failed to load services");
        return;
      }

      if (!Array.isArray(data)) {
        setStatus("bad", "Service data shape invalid. See log.");
        log("Service data not array", data);
        resetServiceDropdown("Service data invalid");
        return;
      }

      // Validate minimum fields; log anomalies, don't crash
      variantsCache = data.map(v => ({
        id: v.id,
        vehicle_size: normalizeVehicleSize(v.vehicle_size),
        price: v.price,
        duration_minutes: v.duration_minutes,
        service: v.service || null
      }));

      setStatus("ok", `Loaded ${variantsCache.length} service variants.`);
      log("Loaded service variants", { count: variantsCache.length });

      // If user already selected vehicle size, render
      const vs = normalizeVehicleSize(elVehicleSize.value);
      if (vs) renderServiceDropdown(vs);
      else resetServiceDropdown("Select vehicle size firstâ€¦");
    }

    elVehicleSize.addEventListener("change", () => {
      const vs = normalizeVehicleSize(elVehicleSize.value);
      if (!vs) {
        resetServiceDropdown("Select vehicle size firstâ€¦");
        return;
      }
      if (!["compact","midsized","oversized"].includes(vs)) {
        resetServiceDropdown("Invalid vehicle size");
        log("Invalid vehicle size selected", { vs });
        return;
      }
      renderServiceDropdown(vs);
    });

    elServiceVariant.addEventListener("change", () => {
      const id = elServiceVariant.value;
      selectedVariant = variantsCache.find(v => v.id === id) || null;
      if (!selectedVariant) {
        elServiceMeta.textContent = "";
        return;
      }
      const cat = selectedVariant.service?.category ?? "Unknown Category";
      const lvl = selectedVariant.service?.level ?? "?";
      elServiceMeta.textContent = `Selected: ${cat} Level ${lvl} â€” ${selectedVariant.duration_minutes} minutes (cleanup +10 and travel NOT included)`;
      recalcEndTimePreview();
    });

    // Core booking flow (no read-after-write after inserts)
async function hasBookingConflict(requestedStartISO, requestedEndISO) {
  const { count, error } = await supabase
  .from("booking_time_windows")
  .select("scheduled_start", { count: "exact", head: true })
  .lt("scheduled_start", requestedEndISO)
  .gt("scheduled_end", requestedStartISO);

  if (error) {
    log("Conflict check failed", error);
    throw new Error("Unable to verify availability. Please try again.");
  }

  return count > 0;
}    
    async function submitBooking() {
      if (isSubmitting) return;
isSubmitting = true;

      elSubmit.disabled = true;
      setStatus("muted", "Submittingâ€¦");

      try {
        const vehicle_size = normalizeVehicleSize(requireNonEmpty("Vehicle size", elVehicleSize.value));
        if (!["compact","midsized","oversized"].includes(vehicle_size)) throw new Error("Vehicle size must be compact, midsized, or oversized (lowercase)");

        const service_variant_id = requireNonEmpty("Service", elServiceVariant.value);
        const email = requireNonEmpty("Email", elEmail.value).toLowerCase();

        const full_name = requireNonEmpty("Full name", elFullName.value);
        const address = requireNonEmpty("Customer address", elAddress.value);
        const phone = (elPhone.value || "").trim() || null;

        const service_address = requireNonEmpty("Service address", elServiceAddress.value);

        // --- Step 2: derive end time from service duration (LOCAL time) ---
const startLocal = parseDateTimeLocalToDate(
  requireNonEmpty("Scheduled start", elStart.value)
);

const durationMinutes = Number(selectedVariant?.duration_minutes);
if (!Number.isFinite(durationMinutes) || durationMinutes <= 0) {
  throw new Error("Invalid service duration. Please re-select your service.");
}
      log("Duration minutes used", {
  raw: selectedVariant?.duration_minutes,
  coerced: durationMinutes
});

// Add duration in LOCAL time
const endLocal = new Date(startLocal.getTime() + durationMinutes * 60_000);

// Autofill + lock the end-time input for UI consistency
elEnd.value = formatDateToDateTimeLocal(endLocal);

// Convert to ISO ONLY for database usage
const scheduled_start = startLocal.toISOString();
const scheduled_end = endLocal.toISOString();
// --- End Step 2 ---

        if (new Date(scheduled_end) <= new Date(scheduled_start)) throw new Error("Scheduled end must be after scheduled start");
        // --- Step 2.5: enforce business hours & weekdays ---
if (!isBookingWithinBusinessRules(startLocal, endLocal)) {
  throw new Error(
    "Bookings are available Mondayâ€“Friday only, between 8:00 AM and 6:00 PM. " +
    "The selected service must fully complete by 6:00 PM."
  );
}
// --- End Step 2.5 ---

        // Calendar conflict check (block overlaps)
const conflict = await hasBookingConflict(scheduled_start, scheduled_end);
if (conflict) {
  throw new Error("Selected time is unavailable. Please choose another slot.");
}
        
        // Step 1: find existing customer by email (SELECT allowed only by email header policy)
        const customerLookupClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
          auth: { persistSession: false },
          global: { headers: { "x-customer-email": email } }
        });

        const { data: existingCustomers, error: selErr } = await customerLookupClient
          .from("customers")
          .select("id,email")
          .eq("email", email)
          .limit(1);

        if (selErr) {
          // If RLS blocks this, you WILL see it here
          log("Customer select error (RLS?)", selErr);
          throw new Error("Customer lookup failed (likely RLS). See log.");
        }

        let customer_id;
        if (existingCustomers && existingCustomers.length === 1) {
          customer_id = existingCustomers[0].id;
          log("Found existing customer", { customer_id, email });
        } else {
          // New customer: generate UUID client-side, insert WITHOUT .select()
          customer_id = crypto.randomUUID();
          const { error: insCustErr } = await supabase
            .from("customers")
            .insert([{ id: customer_id, full_name, email, phone, address }]);

          if (insCustErr) {
            log("Customer insert error", insCustErr);
            throw new Error("Customer creation failed. See log.");
          }
          log("Created new customer (no select after insert)", { customer_id, email });
        }

        // Step 2: create vehicle record (new every booking), client-generated UUID, insert WITHOUT .select()
        const vehicle_id = crypto.randomUUID();
        const vehicle_year = elYear.value ? Number(elYear.value) : null;
        const vehicle_make = (elMake.value || "").trim() || null;
        const vehicle_model = (elModel.value || "").trim() || null;
        const license_plate = (elPlate.value || "").trim() || null;

        const { error: insVehErr } = await supabase
          .from("vehicles")
          .insert([{
            id: vehicle_id,
            customer_id,
            vehicle_size,
            vehicle_year,
            vehicle_make,
            vehicle_model,
            license_plate
          }]);

        if (insVehErr) {
          log("Vehicle insert error", insVehErr);
          throw new Error("Vehicle creation failed. See log.");
        }
        log("Created vehicle (no select after insert)", { vehicle_id });

        // Step 3: create booking (status pending), insert WITHOUT .select()
        const { error: insBookErr } = await supabase
          .from("bookings")
          .insert([{
            customer_id,
            vehicle_id,
            service_variant_id,
            service_address,
            scheduled_start,
            scheduled_end,
            status: "pending"
          }]);

       if (insBookErr) {
  log("Booking insert error", insBookErr);

  // Handle overlap constraint cleanly
  if (insBookErr.code === "23P01" || insBookErr.message?.includes("bookings_no_overlap")) {
    throw new Error("Selected time is unavailable. Please choose another slot.");
  }

  throw new Error("Booking creation failed. Please try again.");
}


        setStatus("ok", "Booking created successfully âœ…");
        log("Booking created", { customer_id, vehicle_id, service_variant_id });

      } catch (e) {
        setStatus("bad", e?.message || "Unknown error");
        log("Submit failure", { message: e?.message, stack: e?.stack });
      } finally {
        isSubmitting = false;
        elSubmit.disabled = false;
      }
    }

    elStart.addEventListener("change", recalcEndTimePreview);
    elSubmit.addEventListener("click", submitBooking);

    // Initial load
    loadServiceVariants();
  </script>
</body>
</html>
