<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Moon Auto Detailing â€” Booking</title>
  <style>
    body {font-family: "Poppins", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif; margin: 0; background-color: #000000;}
    label { display:block; font-weight:600; margin: 10px 0 6px; }
    input, select, button, textarea { width: 100%; padding: 10px; font-size: 16px; }
    textarea { min-height: 70px; }
    button { cursor: pointer; font-weight: 700; }
    .muted { color: #555; font-size: 14px; }
    .ok { color: #0a7a2f; font-weight: 700; }
    .bad { color: #b00020; font-weight: 700; }
    pre { background: #0b1020; color: #e7ecff; padding: 12px; border-radius: 10px; overflow:auto; }
    input[readonly] {
  background-color: #f3f4f6;
  cursor: not-allowed;
}
    /* =====================
   UI POLISH (SAFE) - DESKTOP DEFAULT           
   ===================== */

    .row {
  display: grid;
  grid-template-columns: 1fr 1fr;
  gap: 36px;
}

.row.full {
  grid-template-columns: 1fr;
}

.row > div {
  width: 100%;
}


.page-wrap {
  max-width: 860px;
  margin: 40px auto;
  padding: 0 20px;
}

h1 {
  text-align: center;
  margin-bottom: 4px;
}

.page-subtitle {
  text-align: center;
  color: #6b7280;
  margin-bottom: 24px;
}

.section-title {
  font-size: 18px;
  margin-top: 18px;
  margin-bottom: 8px;
  border-bottom: 1px solid #e5e7eb;
  padding-bottom: 4px;
}

                                /*Mobile Media Configuration*/
/* =====================
   MOBILE ONLY
   ===================== */
@media (max-width: 640px) {

  body {
    margin: 12px;
  }

  /* Stack rows ONLY on mobile */
  .row {
    grid-template-columns: 1fr;
  }

  /* Reduce card padding */
  .booking-card {
    padding: 20px;
  }

  /* Datetime inputs stay centered */
  input[type="datetime-local"] {
    width: 100%;
    display: block;
  }

  /* Center submit button on mobile only */
  #submitBtn {
    display: block;
    margin-left: auto;
    margin-right: auto;
  }
}

  /* Prevent overflow issues, BOX INPUT SIZES AND STYLES */
  input,
select,
textarea {
  width: 100%;
  padding: 12px;
  font-size: 16px;

  border-radius: 14px;
  border: 1px solid #cfcfcf;
  background: #ffffff;

  box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.06);
}
  /* Button sizing */
#submitBtn {
  min-width: 240px;
  padding: 14px 24px;
}


input + input,
input + select,
select + input,
select + select,
textarea {
  margin-top: 8px;
}

    /* =========================
   MOON SITE TYPOGRAPHY + ALIGNMENT
   ========================= */

/* Center all form labels and helper text */
label,
.muted,
.ok,
.bad {
  text-align: center;
}

/* Center inputs visually */
input,
select,
textarea {
  text-align: center;
}

/* Headline styling */
h1 {
  color: #7fb8e6; /* baby blue from site */
  font-weight: 700;
  letter-spacing: 0.5px;
}

/* Section headers */
h3 {
  text-align: center;
  font-weight: 600;
}
/* =========================
   BOOKING BOX STYLE
   ========================= */

.card {border-radius: 0px; padding: 26px; box-shadow: 0 18px 40px rgba(0, 0, 0, 0.12), 0 6px 18px rgba(0, 0, 0, 0.08);
      }
    /* =========================
   PRIMARY BUTTON (SITE MATCH)
   ========================= */

#submitBtn {
  background: #7fb8e6;
  color: #ffffff;
  border-radius: 999px;
  font-weight: 600;
  letter-spacing: 0.5px;
  box-shadow: 0 6px 16px rgba(127, 184, 230, 0.45);
  border: none;
  outline: none;
}

#submitBtn:hover {
  background: #6aaee2;
}

    .booking-card {
  background: #ffffff !important;
  border-radius: 22px;
  padding: 34px;
  box-shadow:
    0 18px 40px rgba(0, 0, 0, 0.12),
    0 6px 18px rgba(0, 0, 0, 0.08);
}
    /* Subtle section separation */
.booking-card .section-title {
  margin-top: 48px;
}

.booking-card .section-title + .row,
.booking-card .section-title + textarea {
  background: rgba(0, 0, 0, 0.02);
  padding: 18px;
  border-radius: 14px;
}
    /* Force rounded inputs everywhere (desktop + mobile) */
input,
select,
textarea {
  border-radius: 16px !important;
}
input[type="datetime-local"] {
  border-radius: 16px !important;
  overflow: hidden;
}
/* Hide debug log in production UI */
#log {
  display: none !important;
}
  </style>                              <!--PAGE UI DESIGN END-->

  
</head>
<body>
  <div class="page-wrap">
       <div class="card booking-card">
  <h1>Moon Auto Detailing â€” Booking</h1>          <!--ACTUAL PHYSICAL TEXT STARTS-->                    
    <p class="page-subtitle">
  Mobile Auto Detailing, WE come to YOU. Book in now, no payment required today.                      <!--ALL BOOKING CONTENT-->
</p>

    <h3 class="section-title">1. Customer Information</h3> <!--Customer-Information-->
    <div class="row">
      <div>
        <label for="fullName">Full name</label>
        <input id="fullName" type="text" placeholder="First Last" autocomplete="name" required />
      </div>
      <div>
        <label for="email">Email</label>
        <input id="email" type="email" placeholder="you@email.com" autocomplete="email" required />
      </div>
    </div>
    <div class="row">
      <div>
        <label for="phone">Phone</label>
        <input id="phone" type="tel" placeholder="(518) 555-1234" autocomplete="tel" />
      </div>
      <div>
        <label for="address">Address</label>
        <input
  id="address"
  type="text"
  autocomplete="off"
  placeholder="Street, City, State ZIP"
  required
/>
      </div>
    </div>

    <h3 class="section-title">2. Vehicle Details</h3> <!--Vehicle-Details-->
    <div class="row">
    <div>
        <label for="vehicleSize">Vehicle size</label> <!--Vehicle size-->
        <select id="vehicleSize" required>
          <option value="">Select sizeâ€¦</option>
          <option value="compact">compact</option>
          <option value="midsized">midsized</option>
          <option value="oversized">oversized</option>
        </select>
      </div>

      <div>
        <label for="serviceVariant">Service</label> <!--Select-service-->
        <select id="serviceVariant" required disabled>
          <option value="">Select vehicle size firstâ€¦</option>
        </select>
        <div id="serviceMeta" class="muted"></div>
      </div>
    </div>
      
    <div class="row"> 
      <div>
        <label for="year">Year</label>
        <input id="year" type="number" min="1900" max="2100" placeholder="2015" />
      </div>
      <div>
        <label for="make">Make</label>
        <input id="make" type="text" placeholder="Toyota" />
      </div>
    </div>
    <div class="row">
      <div>
        <label for="model">Model</label>
        <input id="model" type="text" placeholder="Corolla" />
      </div>
      <div>
        <label for="plate">License plate</label>
        <input id="plate" type="text" placeholder="ABC-1234" />
      </div>
    </div>

    <h3 class="section-title">3. Appointment Time</h3>
    <div class="row full">
      <div>
        <label for="start">Desired Start Time</label>
        <input id="start" type="datetime-local" required />
      </div>
      <div>
        <label for="end">Scheduled End Time</label>
       <input id="end" type="datetime-local" readonly />
      </div>
    </div>
    <label for="serviceAddress">Address where service will be performed </label>
    <input
  id="serviceAddress"
  type="text"
  autocomplete="off"
  placeholder="Start typing service addressâ€¦"
  required
/>

    <button id="submitBtn" class="primary-btn">
  Submit Booking Request
</button>
      <p class="muted" style="margin-top:14px;">
  Your request will be reviewed and confirmed shortly. Youâ€™ll receive a follow-up once itâ€™s scheduled.
</p>

    <div id="status" class="muted" style="margin-top:10px;"></div>
    <pre id="log" style="margin-top:10px; display:none;"></pre>
  </div> <!-- booking-card -->
    
  </div> <!-- page-wrap -->

  <script type="module">
                                                                                                    //DEBUG SWITCH!!                                                                           

    import { createClient } from "https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2/+esm";
    const DEBUG = false;   //SWITCH HERE

    // =========================
    // CONFIG (REPLACE)
    // =========================
// =========================
// BUSINESS RULES (STEP 2)
// =========================
const BUSINESS_RULES = {
  openHour: 8,     // 8:00 AM
  closeHour: 18,  // 6:00 PM (hard stop)
  allowedWeekdays: [1, 2, 3, 4, 5] // Mondayâ€“Friday (JS: 0 = Sunday)
};
    
    const SUPABASE_URL = "https://qgmhugztrpiprnqmcyan.supabase.co";
    const SUPABASE_ANON_KEY = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFnbWh1Z3p0cnBpcHJucW1jeWFuIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NzA1MDk1NjMsImV4cCI6MjA4NjA4NTU2M30.Mo0uRGWCjU1fOa1br2P8j1ogEZf7mDm2JseV8DFnPwI";

    if (!SUPABASE_URL.startsWith("http")) {
      throw new Error("Set SUPABASE_URL and SUPABASE_ANON_KEY in index.html");
    }

    const supabase = createClient(SUPABASE_URL, SUPABASE_ANON_KEY);

    // Elements
    const elVehicleSize = document.getElementById("vehicleSize");
    const elServiceVariant = document.getElementById("serviceVariant");
    const elServiceMeta = document.getElementById("serviceMeta");
    const elStatus = document.getElementById("status");
    const elLog = document.getElementById("log");
    const elSubmit = document.getElementById("submitBtn");

    const elFullName = document.getElementById("fullName");
    const elEmail = document.getElementById("email");
    const elPhone = document.getElementById("phone");
    const elAddress = document.getElementById("address");

    const elYear = document.getElementById("year");
    const elMake = document.getElementById("make");
    const elModel = document.getElementById("model");
    const elPlate = document.getElementById("plate");

    const elStart = document.getElementById("start");
    const elEnd = document.getElementById("end");
    const elServiceAddress = document.getElementById("serviceAddress");

    // Hard-lock end time input (defensive)
elEnd.addEventListener("keydown", (e) => e.preventDefault());
elEnd.addEventListener("paste", (e) => e.preventDefault());

    // State
    let variantsCache = []; // {id, vehicle_size, price, duration_minutes, service:{category,level}}
    let selectedVariant = null;
    let isSubmitting = false;

                                                                            //SWITCH CHANGES THIS DEBUG
    function log(message, obj) {
  if (!DEBUG) return;

  const ts = new Date().toISOString();
  const line = obj
    ? `${ts}  ${message}\n${JSON.stringify(obj, null, 2)}\n`
    : `${ts}  ${message}\n`;

  console.log(message, obj ?? "");
  elLog.textContent = (elLog.textContent || "") + line;
}


    function setStatus(type, text) {
      elStatus.className = type === "ok" ? "ok" : type === "bad" ? "bad" : "muted";
      elStatus.textContent = text;
    }

    function normalizeVehicleSize(v) {
      return (v || "").trim().toLowerCase();
    }

    function requireNonEmpty(name, value) {
      const v = (value || "").trim();
      if (!v) throw new Error(`${name} is required`);
      return v;
    }

    function parseLocalDateTimeToISO(dtLocal) {
      // dtLocal is "YYYY-MM-DDTHH:MM"
      // Interpret as local time, convert to ISO string with timezone.
      const d = new Date(dtLocal);
      if (Number.isNaN(d.getTime())) throw new Error("Invalid date/time value");
      return d.toISOString();
    }
// === ADD THESE TWO FUNCTIONS RIGHT HERE (step 1) ===
function parseDateTimeLocalToDate(dtLocal) {
  // dtLocal is "YYYY-MM-DDTHH:MM" from <input type="datetime-local">
  const [datePart, timePart] = dtLocal.split("T");
  const [y, m, d] = datePart.split("-").map(Number);
  const [hh, mm] = timePart.split(":").map(Number);
  // Create a LOCAL Date (no UTC conversion)
  return new Date(y, m - 1, d, hh, mm, 0, 0);
}

function formatDateToDateTimeLocal(d) {
  const pad = (n) => String(n).padStart(2, "0");
  const yyyy = d.getFullYear();
  const mm = pad(d.getMonth() + 1);
  const dd = pad(d.getDate());
  const hh = pad(d.getHours());
  const min = pad(d.getMinutes());
  return `${yyyy}-${mm}-${dd}T${hh}:${min}`;
}
// =========================
// BUSINESS HOURS VALIDATION
// =========================
function isBookingWithinBusinessRules(startLocal, endLocal) {
  // Must be same calendar day
  if (
    startLocal.getFullYear() !== endLocal.getFullYear() ||
    startLocal.getMonth() !== endLocal.getMonth() ||
    startLocal.getDate() !== endLocal.getDate()
  ) {
    return false;
  }

  // Weekday check (Monâ€“Fri only)
  const day = startLocal.getDay();
  if (!BUSINESS_RULES.allowedWeekdays.includes(day)) {
    return false;
  }

  // Time window check
  const startHour = startLocal.getHours() + startLocal.getMinutes() / 60;
  const endHour = endLocal.getHours() + endLocal.getMinutes() / 60;

  if (startHour < BUSINESS_RULES.openHour) return false;
  if (endHour > BUSINESS_RULES.closeHour) return false;

  return true;
}

   function recalcEndTimePreview() {
  if (!elStart.value) return;
  if (!selectedVariant?.duration_minutes) return;

  const startLocal = parseDateTimeLocalToDate(elStart.value);
  const durationMinutes = Number(selectedVariant.duration_minutes);

  const endLocal = new Date(startLocal.getTime() + durationMinutes * 60_000);
  elEnd.value = formatDateToDateTimeLocal(endLocal);
}


// ðŸ‘‡ ADD THIS FUNCTION DIRECTLY HERE
function computeScheduledEnd(startLocal, durationMinutes) {
  const startDate = new Date(startLocal);
  if (Number.isNaN(startDate.getTime())) {
    throw new Error("Invalid scheduled start time");
  }

  const endDate = new Date(startDate.getTime() + durationMinutes * 60 * 1000);

  const pad = n => String(n).padStart(2, "0");
  return `${endDate.getFullYear()}-${pad(endDate.getMonth() + 1)}-${pad(endDate.getDate())}T${pad(endDate.getHours())}:${pad(endDate.getMinutes())}`;
}
    function resetServiceDropdown(msg) {
      elServiceVariant.innerHTML = `<option value="">${msg}</option>`;
      elServiceVariant.disabled = true;
      elServiceMeta.textContent = "";
      selectedVariant = null;
    }

    function renderServiceDropdown(vehicleSize) {
      const filtered = variantsCache
        .filter(v => v.vehicle_size === vehicleSize)
        .map(v => {
          const cat = v.service?.category ?? "Unknown Category";
          const lvl = (v.service?.level ?? "?");
          const label = `${cat} â€” Level ${lvl} (${v.vehicle_size}) â€” ${v.duration_minutes} min â€” $${v.price}`;
          return { id: v.id, label };
        });

      if (!filtered.length) {
        resetServiceDropdown("No services available for this vehicle size");
        log("No service variants found for vehicle size", { vehicleSize, totalVariants: variantsCache.length });
        return;
      }

      elServiceVariant.disabled = false;
      elServiceVariant.innerHTML = `<option value="">Select serviceâ€¦</option>` +
        filtered.map(o => `<option value="${o.id}">${o.label}</option>`).join("");
    }

    async function loadServiceVariants() {
      setStatus("muted", "Loading servicesâ€¦");
      resetServiceDropdown("Loadingâ€¦");

                                              // Explicit embedded relation; DO NOT rely on implicit joins returning null silently
                                              //THIS IS SERVICE_VARIANTS NOT LOADING DEBUG 
      const { data, error } = await supabase
        .from("service_variants")
        .select("id, vehicle_size, price, duration_minutes, service:services(category, level)")
        .eq("active", true);

      if (error) {
        setStatus("bad", "Failed to load services. See log.");
        log("Service load error", error);
        resetServiceDropdown("Failed to load services");
        return;
      }

      if (!Array.isArray(data)) {
        setStatus("bad", "Service data shape invalid. See log.");
        log("Service data not array", data);
        resetServiceDropdown("Service data invalid");
        return;
      }

      // Validate minimum fields; log anomalies, don't crash
      variantsCache = data.map(v => ({
        id: v.id,
        vehicle_size: normalizeVehicleSize(v.vehicle_size),
        price: v.price,
        duration_minutes: v.duration_minutes,
        service: v.service || null
      }));

      setStatus("muted", "");
      log("Loaded service variants", { count: variantsCache.length });            //SERVICE VARIANTS DEBUG ENDS HERE

      // If user already selected vehicle size, render
      const vs = normalizeVehicleSize(elVehicleSize.value);
      if (vs) renderServiceDropdown(vs);
      else resetServiceDropdown("Select vehicle size firstâ€¦");
    }

    elVehicleSize.addEventListener("change", () => {
      const vs = normalizeVehicleSize(elVehicleSize.value);
      if (!vs) {
        resetServiceDropdown("Select vehicle size firstâ€¦");
        return;
      }
      if (!["compact","midsized","oversized"].includes(vs)) {
        resetServiceDropdown("Invalid vehicle size");
        log("Invalid vehicle size selected", { vs });
        return;
      }
      renderServiceDropdown(vs);
    });

    elServiceVariant.addEventListener("change", () => {
      const id = elServiceVariant.value;
      selectedVariant = variantsCache.find(v => v.id === id) || null;
      if (!selectedVariant) {
        elServiceMeta.textContent = "";
        return;
      }
      const cat = selectedVariant.service?.category ?? "Unknown Category";
      const lvl = selectedVariant.service?.level ?? "?";
      elServiceMeta.textContent = `Selected: ${cat} Level ${lvl} â€” ${selectedVariant.duration_minutes} minutes (cleanup +10 and travel NOT included)`;
      recalcEndTimePreview();
    });

    // Core booking flow (no read-after-write after inserts)
async function hasBookingConflict(requestedStartISO, requestedEndISO) {
  const { count, error } = await supabase
  .from("booking_time_windows")
  .select("scheduled_start", { count: "exact", head: true })
  .lt("scheduled_start", requestedEndISO)
  .gt("scheduled_end", requestedStartISO);

  if (error) {
    log("Conflict check failed", error);
    throw new Error("Unable to verify availability. Please try again.");
  }

  return count > 0;
}    
    async function submitBooking() {
      if (isSubmitting) return;
isSubmitting = true;

      elSubmit.disabled = true;
      setStatus("muted", "Submittingâ€¦");

      try {
        const vehicle_size = normalizeVehicleSize(requireNonEmpty("Vehicle size", elVehicleSize.value));
        if (!["compact","midsized","oversized"].includes(vehicle_size)) throw new Error("Vehicle size must be compact, midsized, or oversized (lowercase)");

        const service_variant_id = requireNonEmpty("Service", elServiceVariant.value);
        const email = requireNonEmpty("Email", elEmail.value).toLowerCase();

        const full_name = requireNonEmpty("Full name", elFullName.value);
        const address = requireNonEmpty("Customer address", elAddress.value);
        const phone = (elPhone.value || "").trim() || null;

        const service_address = requireNonEmpty("Service address", elServiceAddress.value);

        // --- Step 2: derive end time from service duration (LOCAL time) ---
const startLocal = parseDateTimeLocalToDate(
  requireNonEmpty("Scheduled start", elStart.value)
);

const durationMinutes = Number(selectedVariant?.duration_minutes);
if (!Number.isFinite(durationMinutes) || durationMinutes <= 0) {
  throw new Error("Invalid service duration. Please re-select your service.");
}
      log("Duration minutes used", {
  raw: selectedVariant?.duration_minutes,
  coerced: durationMinutes
});

// Add duration in LOCAL time
const endLocal = new Date(startLocal.getTime() + durationMinutes * 60_000);

// Autofill + lock the end-time input for UI consistency
elEnd.value = formatDateToDateTimeLocal(endLocal);

// Convert to ISO ONLY for database usage
const scheduled_start = startLocal.toISOString();
const scheduled_end = endLocal.toISOString();
// --- End Step 2 ---

        if (new Date(scheduled_end) <= new Date(scheduled_start)) throw new Error("Scheduled end must be after scheduled start");
        // --- Step 2.5: enforce business hours & weekdays ---
if (!isBookingWithinBusinessRules(startLocal, endLocal)) {
  throw new Error(
    "Bookings are available Mondayâ€“Friday only, between 8:00 AM and 6:00 PM. " +
    "The selected service must fully complete by 6:00 PM."
  );
}
// --- End Step 2.5 ---

        // Calendar conflict check (block overlaps)
const conflict = await hasBookingConflict(scheduled_start, scheduled_end);
if (conflict) {
  throw new Error("Selected time is unavailable. Please choose another slot.");
}
        
        // Step 1: find existing customer by email (SELECT allowed only by email header policy)
        const customerLookupClient = createClient(SUPABASE_URL, SUPABASE_ANON_KEY, {
          auth: { persistSession: false },
          global: { headers: { "x-customer-email": email } }
        });

        const { data: existingCustomers, error: selErr } = await customerLookupClient
          .from("customers")
          .select("id,email")
          .eq("email", email)
          .limit(1);

        if (selErr) {
          // If RLS blocks this, you WILL see it here
          log("Customer select error (RLS?)", selErr);
          throw new Error("Customer lookup failed (likely RLS). See log.");
        }

        let customer_id;
        if (existingCustomers && existingCustomers.length === 1) {
          customer_id = existingCustomers[0].id;
          log("Found existing customer", { customer_id, email });
        } else {
          // New customer: generate UUID client-side, insert WITHOUT .select()
          customer_id = crypto.randomUUID();
          const { error: insCustErr } = await supabase
            .from("customers")
            .insert([{ id: customer_id, full_name, email, phone, address }]);

          if (insCustErr) {
            log("Customer insert error", insCustErr);
            throw new Error("Customer creation failed. See log.");
          }
          log("Created new customer (no select after insert)", { customer_id, email });
        }

        // Step 2: create vehicle record (new every booking), client-generated UUID, insert WITHOUT .select()
        const vehicle_id = crypto.randomUUID();
        const vehicle_year = elYear.value ? Number(elYear.value) : null;
        const vehicle_make = (elMake.value || "").trim() || null;
        const vehicle_model = (elModel.value || "").trim() || null;
        const license_plate = (elPlate.value || "").trim() || null;

        const { error: insVehErr } = await supabase
          .from("vehicles")
          .insert([{
            id: vehicle_id,
            customer_id,
            vehicle_size,
            vehicle_year,
            vehicle_make,
            vehicle_model,
            license_plate
          }]);

        if (insVehErr) {
          log("Vehicle insert error", insVehErr);
          throw new Error("Vehicle creation failed. See log.");
        }
        log("Created vehicle (no select after insert)", { vehicle_id });

        // Step 3: create booking (status pending), insert WITHOUT .select()
        const { error: insBookErr } = await supabase
          .from("bookings")
          .insert([{
            customer_id,
            vehicle_id,
            service_variant_id,
            service_address,
            scheduled_start,
            scheduled_end,
            status: "pending"
          }]);

       if (insBookErr) {
  log("Booking insert error", insBookErr);

  // Handle overlap constraint cleanly
  if (insBookErr.code === "23P01" || insBookErr.message?.includes("bookings_no_overlap")) {
    throw new Error("Selected time is unavailable. Please choose another slot.");
  }

  throw new Error("Booking creation failed. Please try again.");
}


        setStatus("ok", "Your booking has been received and will be confirmed shortly.");
        log("Booking created", { customer_id, vehicle_id, service_variant_id });

      } catch (e) {
        setStatus("bad", e?.message || "Unknown error");
        log("Submit failure", { message: e?.message, stack: e?.stack });
      } finally {
        isSubmitting = false;
        elSubmit.disabled = false;
      }
    }

    elStart.addEventListener("change", recalcEndTimePreview);
    elSubmit.addEventListener("click", submitBooking);

    // =========================
// GOOGLE PLACES AUTOCOMPLETE
// =========================
function initAddressAutocomplete() {
  if (!window.google || !google.maps?.places) return;

  const options = {
    types: ["address"],
    componentRestrictions: { country: "us" },
    fields: ["address_components"]
  };

  function attachAutocomplete(inputEl) {
    const autocomplete = new google.maps.places.Autocomplete(inputEl, options);

    autocomplete.addListener("place_changed", () => {
  const place = autocomplete.getPlace();
  if (!place || !place.address_components) return;

  const components = {};
  for (const c of place.address_components) {
    for (const t of c.types) {
      components[t] = c.long_name;
    }
  }

  const street =
    [components.street_number, components.route]
      .filter(Boolean)
      .join(" ");

  const city =
    components.locality ||
    components.sublocality ||
    components.postal_town ||
    "";

  const state = components.administrative_area_level_1 || "";
  const zip = components.postal_code || "";

  const fullAddress = [street, city, state, zip]
    .filter(Boolean)
    .join(", ");

  inputEl.value = fullAddress;
});
  }

  const customerAddress = document.getElementById("address");
  const serviceAddress = document.getElementById("serviceAddress");

  if (customerAddress) attachAutocomplete(customerAddress);
  if (serviceAddress) attachAutocomplete(serviceAddress);
}


    // Initial load
    loadServiceVariants();
initAddressAutocomplete();                                                                  //PLACES API LINK//
  </script>
    <script
  src="https://maps.googleapis.com/maps/api/js?key=AIzaSyATTPIoF8zyQ7kYttesmmHvklxibeVQl9k&libraries=places&loading=async"
  async
  defer
></script>


</body>
</html>
